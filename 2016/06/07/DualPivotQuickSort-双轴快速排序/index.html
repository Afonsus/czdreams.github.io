<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Sort DualPivotQuickSort," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="这个算法是Arrays.java中给基本类型的数据排序使用的具体实现">
<meta property="og:type" content="article">
<meta property="og:title" content="DualPivotQuickSort 双轴快速排序">
<meta property="og:url" content="http://yoursite.com/2016/06/07/DualPivotQuickSort-双轴快速排序/index.html">
<meta property="og:site_name" content="ThronBirds Blog">
<meta property="og:description" content="这个算法是Arrays.java中给基本类型的数据排序使用的具体实现">
<meta property="og:updated_time" content="2016-06-20T07:48:39.971Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DualPivotQuickSort 双轴快速排序">
<meta name="twitter:description" content="这个算法是Arrays.java中给基本类型的数据排序使用的具体实现">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/06/07/DualPivotQuickSort-双轴快速排序/"/>

  <title> DualPivotQuickSort 双轴快速排序 | ThronBirds Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ThronBirds Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Coder</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                DualPivotQuickSort 双轴快速排序
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-07T16:04:41+08:00" content="2016-06-07">
              2016-06-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Algorithms/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithms</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/07/DualPivotQuickSort-双轴快速排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/07/DualPivotQuickSort-双轴快速排序/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>这个算法是Arrays.java中给基本类型的数据排序使用的具体实现<br><a id="more"></a></p>
<p>这个算法是Arrays.java中给基本类型的数据排序使用的具体实现。它针对每种基本类型都做了实现，实现的方式有稍微的差异，但是思路都是相同的，所以这里只挑了int类型的排序来看。</p>
<p>整个实现中的思路是 首先检查数组的长度，比一个阈值小的时候直接使用双轴快排。其它情况下，先检查数组中数据的顺序连续性。把数组中连续升序或者连续降序的信息记录下来，顺便把连续降序的部分倒置。这样数据就被切割成一段段连续升序的数列。</p>
<p>如果顺序连续性好，直接使用TimSort算法。这个我们之前介绍过，TimSort算法的核心在于利用数列中的原始顺序，所以可以提高很多效率。这里的TimSort算法是之前介绍的TimSort算法的精简版，剪掉了动态阈值的那一部分。</p>
<p>顺序连续性不好的数组直接使用了 双轴快排 + 成对插入排序。成对插入排序是插入排序的改进版，它采用了同时插入两个元素的方式调高效率。双轴快排是从传统的单轴快排到3-way快排演化过来的，网上之前已经有很多博客介绍这种算法。这里推荐<a href="http://rerun.me/2013/06/13/quicksorting-3-way-and-dual-pivot/" target="_blank" rel="external">国外一篇文章</a>，它的3张图和下面的代码帮助我理解了快排，3-way和双轴快排之间的关系。</p>
<p>代码风格来看感觉不如之前TimSort的代码风格好。代码中的变量命名大部分都是a, b, i, k, j, t这种，让人不好理解。所以建议大家日常写代码也不要使用这种不明含义的命名。最好能做到让其它人一看就懂，比如说用index代替i, 用 temp代替t等等。好在它的核心代码部分注释很全，看起来到不麻烦。</p>
<pre><code>final class DualPivotQuicksort{
    /**
     * 保护这个类不被实例化
     */
    private DualPivotQuickSort(){}

    /**
     * 待合并的序列的最大数量
     */
    private static final int MAX_RUN_COUNT = 67;

    /**
     * 待合并的序列的最大长度
     */
    private static final int MAX_RUN_LENGTH = 33;

    /**
     * 如果参与排序的数组长度小于这个值，优先使用快速排序而不是归并排序
     */
    private static final int QUICKSORT_THRESHOLD = 286;

    /**
     * 如果参与排序的数组长度小于这个值，有限考虑插入排序，而不是快速排序
     */
    private static final int INSERTION_SORT_THRESHOLD = 47; 

    /**
     * 给指定数组排序
     *
     * @param 指定的数组
     */
    public static void sort(int[] a) {
        sort(a, 0, a.length - 1);
    }

    /**
     * 给指定数组的指定范围排序
     * @param 指定的数组
     * @param 指定范围的第一个元素(包括)
     * @param 指定范围的最后一个元素(不包括)
     */
    public static void sort(int[] a, int left, int right) {

        if(right-left &lt; QUICKSORT_THRESHOLD){
            sort(a, left, right, true);
            return;
        }

        /**
         * run[i] 意味着第i个有序数列开始的位置，（升序或者降序）
         **/
        int[] run =new int[MAX_RUN_COUNT + 1];
        int count=0; run[0] = left;

        // 检查数组是不是已经接近有序状态
        for(int k = left; k &lt; right; run[count] = k) {
            if(a[k] &lt; a[k + 1]){ // 升序
                while(++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]) ;
            } else if(a[k] &gt; a[k + 1]) { // 降序
                while(++k &lt;=right &amp;&amp; a[k - 1] &gt;= a[k]);
                //如果是降序的，找出k之后，把数列倒置
                for (int lo = run[count],hi = k;++lo &lt; --hi) {
                    int t = a[lo]; a[lo] = a[hi]; a[hi] = t;
                }
            } else { // 相等
                for(int m = MAX_RUN_LENGTH; ++k &lt;=right &amp;&amp; a[k - 1] == a[k];) {
                    // 数列中有至少MAX_RUN_LENGTH的数据相等的时候，直接使用快排。
                    // 这里为什么这么处理呢？
                    if(--m == 0){
                        sort(a, left, right, true);
                        return;
                    }
                }
            }

            /**
             * 数组并非高度有序，使用快速排序,因为数组中有序数列的个数超过了MAX_RUN_COUNT
             */
            if(++count == MAX_RUN_COUNT) {
                sort(a, left, right, true);
                return;
            }
        }
        //检查特殊情况
        if(run[count] == right++){ // 最后一个有序数列只有最后一个元素
            run[++count] =right; // 那给最后一个元素的后面加一个哨兵
        } else if(count == 1) { // 整个数组中只有一个有序数列，说明数组已经有序啦，不需要排序了
            return;
        }

        /**
         * 创建合并用的临时数组。
         * 注意： 这里变量right被加了1，它在数列最后一个元素位置+1的位置
         * 这里没看懂，没发现后面的奇数处理和偶数处理有什么不同
         */
        int[] b; byte odd=0;
        for(int n=1; (n &lt;&lt;= 1) &lt; count; odd ^=1);

        if(odd == 0) {
            b=a;a= new int[b.length];
            for(int i=left -1; ++i &lt; right; a[i] = b[i]);
        } else {
            b=new int[a.length];
        }

        // 合并
        // 最外层循环，直到count为1，也就是栈中待合并的序列只有一个的时候，标志合并成功
        // a 做原始数组，b 做目标数组
        for(int last; count &gt; 1; count = last) { 
            // 遍历数组，合并相邻的两个升序序列
            for(int k = (last = 0) + 2; k &lt;= count; k += 2) {
                // 合并run[k-2] 与 run[k-1]两个序列
                int hi = run[k], mi = run[k - 1];
                for(int i = run[k - 2], p = i,q = mi; i &lt; hi; ++i){
                    // 这里我给源码加了一个括号，这样好理解一点。 之前总觉得它会出现数组越界问题，
                    // 后来加了这个括号之后发现是没有问题的
                    if(q &gt;= hi  ||  (p &lt; mi &amp;&amp; a[p] &lt;= a[q])) {
                        b[i] = a[p++];
                    } else {
                        b[i] = a[q++];
                    }
                }
                // 这里把合并之后的数列往前移动
                run[++last] = hi;
            }
            // 如果栈的长度为奇数，那么把最后落单的有序数列copy过对面
            if((count &amp; 1) != 0) {
                for(int i = right, lo =run[count -1]; --i &gt;= lo; b[i] = a[i]);
                run[++last] = right;
            }
            //临时数组，与原始数组对调，保持a做原始数组，b 做目标数组
            int[] t = a; a = b; b = t;
        }

    }

    /**
     * 使用双轴快速排序给指定数组的指定范围排序
     * @param a 参与排序的数组
     * @param left 范围内最左边的元素的位置(包括该元素)
     * @param right 范围内最右边的元素的位置(包括该元素)
     * @param leftmost 指定的范围是否在数组的最左边
     */
     private static void sort(int[] a, int left, int right, boolean leftmost) {
        int length = right - left + 1;

        // 小数组使用插入排序
        if (length &lt; INSERTION_SORT_THRESHOLD) {
            if(leftmost) {
                /**
                 * 经典的插入排序算法，不带哨兵。做了优化，在leftmost情况下使用
                 */
                for(int i = left, j = i; i &lt; right; j = ++i) {
                    int ai = a[i + 1];
                    while(ai &lt; a[j]){
                        a[j + 1] = a[j];
                        if(j-- == left){
                            break;
                        }
                    }
                    a[j + 1] = ai;
                }
            } else {

               /**
                * 首先跨过开头的升序的部分
                */
                do {
                    if(left &gt; right) {
                        return;
                    }
                }while(a[++left] &gt;= a[left - 1]);

                /**
                 * 这里用到了成对插入排序方法，它比简单的插入排序算法效率要高一些
                 * 因为这个分支执行的条件是左边是有元素的
                 * 所以可以直接从left开始往前查找。
                 */
                for(int k = left; ++left &lt;= right; k = ++left) {
                    int a1 = a[k], a2 = a[left];

                    //保证a1&gt;=a2
                    if(a1 &lt; a2) {
                        a2 = a1; a1 = a[left];
                    }
                    //先把两个数字中较大的那个移动到合适的位置
                    while(a1 &lt; a[--k]) {
                        a[k + 2] = a[k]; //这里每次需要向左移动两个元素
                    }
                    a[++k + 1] = a1;
                    //再把两个数字中较小的那个移动到合适的位置
                    while(a2 &lt; a[--k]) {
                        a[k + 1] = a[k]; //这里每次需要向左移动一个元素
                    }
                    a[k + 1] = a2;
                }
                int last = a[right];

                while(last &lt; a[--right]) {
                    a[right + 1] = last;
                }
                a[right + 1] = last;
            }
            return;
        }

        // length / 7 的一种低复杂度的实现, 近似值(length * 9 / 64 + 1)
        int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;

        // 对5段靠近中间位置的数列排序，这些元素最终会被用来做轴(下面会讲)
        // 他们的选定是根据大量数据积累经验确定的
        int e3 = (left + right) &gt;&gt;&gt; 1; //中间值
        int e2 = e3 - seventh;
        int e1 = e2 - seventh;
        int e4 = e3 + seventh;
        int e5 = e4 + seventh;

        //这里是手写的冒泡排序，没有for循环
        if(a[e2] &lt; a[e1]){ int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }
        if (a[e3] &lt; a[e2]) {
            int t = a[e3]; a[e3] = a[e2]; a[e2] = t;
            if (t &lt; a[e1]) {
                a[e2] = a[e1]; a[e1] = t; 
            }
        }
        if (a[e4] &lt; a[e3]) {
            int t = a[e4]; a[e4] = a[e3]; a[e3] = t;
            if (t &lt; a[e2]) {
                a[e3] = a[e2]; a[e2] = t;
                if (t &lt; a[e1]) {
                    a[e2] = a[e1]; a[e1] = t;
                }
            }
        }
        if (a[e5] &lt; a[e4]) {
            int t = a[e5]; a[e5] = a[e4]; a[e4] = t;
            if (t &lt; a[e3]) {
                a[e4] = a[e3]; a[e3] = t;
                if (t &lt; a[e2]) {
                    a[e3] = a[e2]; a[e2] = t;
                    if (t &lt; a[e1]) {
                        a[e2] = a[e1]; a[e1] = t;
                    }
                }
            }
        }

        //指针
        int less = left;   // 中间区域的首个元素的位置
        int great = right; //右边区域的首个元素的位置
        if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {
            /*
             * 使用5个元素中的2，4两个位置，他们两个大致处在四分位的位置上。
             * 需要注意的是pivot1 &lt;= pivot2
             */
            int pivot1 = a[e2];
            int pivot2 = a[e4];

            /*
             * The first and the last elements to be sorted are moved to the
             * locations formerly occupied by the pivots. When partitioning
             * is complete, the pivots are swapped back into their final
             * positions, and excluded from subsequent sorting.
             * 第一个和最后一个元素被放到两个轴所在的位置。当阶段性的分段结束后
             * 他们会被分配到最终的位置并从子排序阶段排除
             */
            a[e2] = a[left];
            a[e4] = a[right];

            /*
             * 跳过一些队首的小于pivot1的值，跳过队尾的大于pivot2的值
             */
            while (a[++less] &lt; pivot1);
            while (a[--great] &gt; pivot2);

            /*
             * Partitioning:
             *
             *   left part           center part                   right part
             * +--------------------------------------------------------------+
             * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |
             * +--------------------------------------------------------------+
             *               ^                          ^       ^
             *               |                          |       |
             *              less                        k     great
             *
             * Invariants:
             *
             *              all in (left, less)   &lt; pivot1
             *    pivot1 &lt;= all in [less, k)     &lt;= pivot2
             *              all in (great, right) &gt; pivot2
             *
             * Pointer k is the first index of ?-part.
             */
            outer:
            for (int k = less - 1; ++k &lt;= great; ) {
                int ak = a[k];
                if (ak &lt; pivot1) { // Move a[k] to left part
                    a[k] = a[less];
                    /*
                     * 这里考虑的好细致，&quot;a[i] = b; i++&quot;的效率要好过
                     * &apos;a[i++] = b&apos;
                     */
                    a[less] = ak;
                    ++less;
                } else if (ak &gt; pivot2) { // Move a[k] to right part
                    while (a[great] &gt; pivot2) {
                        if (great-- == k) { // k遇到great本次分割
                            break outer;
                        }
                    }
                    if (a[great] &lt; pivot1) { // a[great] &lt;= pivot2
                        a[k] = a[less];
                        a[less] = a[great];
                        ++less;
                    } else { // pivot1 &lt;= a[great] &lt;= pivot2
                        a[k] = a[great];
                    }
                    /*
                     * 同上，用&quot;a[i]=b;i--&quot;代替&quot;a[i--] = b&quot;
                     */
                    a[great] = ak;
                    --great;
                }
            } // 分割阶段结束出来的位置,上一个outer结束的位置

            // 把两个放在外面的轴放回他们应该在的位置上 
            a[left]  = a[less  - 1]; a[less  - 1] = pivot1;
            a[right] = a[great + 1]; a[great + 1] = pivot2;

            // 把左边和右边递归排序，跟普通的快速排序差不多
            sort(a, left, less - 2, leftmost);
            sort(a, great + 2, right, false);

            /*
             * If center part is too large (comprises &gt; 4/7 of the array),
             * swap internal pivot values to ends.
             * 如果中心区域太大，超过数组长度的 4/7。就先进行预处理，再参与递归排序。
             * 预处理的方法是把等于pivot1的元素统一放到左边，等于pivot2的元素统一
             * 放到右边,最终产生一个不包含pivot1和pivot2的数列，再拿去参与快排中的递归。
             */
            if (less &lt; e1 &amp;&amp; e5 &lt; great) {
                /*
                 * Skip elements, which are equal to pivot values.
                 */
                while (a[less] == pivot1) {
                    ++less;
                }

                while (a[great] == pivot2) {
                    --great;
                }

                /*
                 * Partitioning:
                 *
                 *   left part         center part                  right part
                 * +----------------------------------------------------------+
                 * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |
                 * +----------------------------------------------------------+
                 *              ^                        ^       ^
                 *              |                        |       |
                 *             less                      k     great
                 *
                 * Invariants:
                 *
                 *              all in (*,  less) == pivot1
                 *     pivot1 &lt; all in [less,  k)  &lt; pivot2
                 *              all in (great, *) == pivot2
                 *
                 * Pointer k is the first index of ?-part.
                 */
                outer:
                for (int k = less - 1; ++k &lt;= great; ) {
                    int ak = a[k];
                    if (ak == pivot1) { // Move a[k] to left part
                        a[k] = a[less];
                        a[less] = ak;
                        ++less;
                    } else if (ak == pivot2) { // Move a[k] to right part
                        while (a[great] == pivot2) {
                            if (great-- == k) {
                                break outer;
                            }
                        }
                        if (a[great] == pivot1) { // a[great] &lt; pivot2
                            a[k] = a[less];
                            /*
                             * Even though a[great] equals to pivot1, the
                             * assignment a[less] = pivot1 may be incorrect,
                             * if a[great] and pivot1 are floating-point zeros
                             * of different signs. Therefore in float and
                             * double sorting methods we have to use more
                             * accurate assignment a[less] = a[great].
                             */
                            a[less] = pivot1;
                            ++less;
                        } else { // pivot1 &lt; a[great] &lt; pivot2
                            a[k] = a[great];
                        }
                        a[great] = ak;
                        --great;
                    }
                } // outer结束的位置
            }

            // Sort center part recursively
            sort(a, less, great, false);

        } else { // 这里选取的5个元素刚好相等，使用传统的3-way快排 

            /*
             * 在5个元素中取中值
             */
            int pivot = a[e3];

            /*
             * 
             * Partitioning degenerates to the traditional 3-way
             * (or &quot;Dutch National Flag&quot;) schema:
             *
             *   left part    center part              right part
             * +-------------------------------------------------+
             * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |
             * +-------------------------------------------------+
             *              ^              ^        ^
             *              |              |        |
             *             less            k      great
             *
             * Invariants:
             *
             *   all in (left, less)   &lt; pivot
             *   all in [less, k)     == pivot
             *   all in (great, right) &gt; pivot
             *
             * Pointer k is the first index of ?-part.
             */
            for (int k = less; k &lt;= great; ++k) {
                if (a[k] == pivot) {
                    continue;
                }
                int ak = a[k];
                if (ak &lt; pivot) { // 把a[k]移动到左边去，把center区向右滚动一个单位
                    a[k] = a[less];
                    a[less] = ak;
                    ++less;
                } else { // a[k] &gt; pivot - 把a[k]移动到右边
                    while (a[great] &gt; pivot) { // 先找到右边最后一个比pivot小的值
                        --great;
                    }
                    if (a[great] &lt; pivot) { // a[great] &lt;= pivot ，把他移到左边
                        a[k] = a[less];
                        a[less] = a[great];
                        ++less;
                    } else { // a[great] == pivot //如果相等，中心区直接扩展
                        /*
                         * 这里因为是整型值，所以a[k] == a[less] == pivot;
                         */
                        a[k] = pivot;
                    }
                    a[great] = ak;
                    --great;
                }
            }

            /*
             * 左右两边还没有完全排序，所以递归解决
             * 中心区只有一个值，不再需要排序
             */
            sort(a, left, less - 1, leftmost);
            sort(a, great + 1, right, false);
        }
     }
}
</code></pre>
      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Sort-DualPivotQuickSort/" rel="tag">#Sort DualPivotQuickSort</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/31/Java泛型里的协变和逆变/" rel="next" title="Java泛型里的协变和逆变">
                <i class="fa fa-chevron-left"></i> Java泛型里的协变和逆变
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/06/07/TimSort算法/" rel="prev" title="TimSort算法">
                TimSort算法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/06/07/DualPivotQuickSort-双轴快速排序/"
           data-title="DualPivotQuickSort 双轴快速排序" data-url="http://yoursite.com/2016/06/07/DualPivotQuickSort-双轴快速排序/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xsp7e.com1.z0.glb.clouddn.com/20150904170102_HNJPs.jpeg"
               alt="Chenzhi" />
          <p class="site-author-name" itemprop="name">Chenzhi</p>
          <p class="site-description motion-element" itemprop="description">Java NodeJs NoSql</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <p class="post-toc-empty">此文章未包含目录</p>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chenzhi</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ThronBirds"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  

</body>
</html>
